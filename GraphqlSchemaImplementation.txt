 			  Graphql API Implementation
.....................................................................................
In order to build apis we have many technologies

1.REST
2.Graphql
3.Grpc

How to build REST apis?

  Restfull webservices are built based on "Resources" in the Problem Domain.

Resources are represented by "Object" which expose Data.

Eg:
 CustomerResource,OrderResource,PaymentResource,CourseResource

Resources are identified by "URL" 
  => /api/customers GET | POST | DELETE | UPDATE

In Graphql apps are built based on "Models" Which are objects

What ever language we have to think in terms of Objects
...................................................................................
Graphql Schema Language                         Programming Langauge
....................................................................................
  Schema                                        class or Object

  Customer                                      class Customer {} | let Customer={}

Object shape is described by "Schema". 

Schema is nothing but "Plan"

In Graphql context, the "Problem domain"  is represented by "Schema language"
....................................................................................
			SDL - Schema Definition Language
....................................................................................
SDL Core concepts:
..................

1.Type System:
...............
   The Type system defines the platform and language independant data types which describe what data can be quried by client.

Schema Type Systems =============================>Programming language Type System
eg:
   String           =============================>javascript -string

    Int             ==============================>javascript -number

Client                                        Server

 Query ----|SDL-----send request --------    |SDL---Models--->Bizlogic(services|							 resolvers)-->Datasources

					  |---->java,kotlin,scala,c#,python -jvm
					  |---->js,typescript -node
			SDL implementation|---->
					  |---->
					
	

How to start with SDL?

we need to define type.

syntax:
 type TypeName{
    field:Type
 }
IN SDL, there is root type, every type is dervied from the root type.

type Schema {
  query:Query
  mutation:Mutation
  subscription:Subscription
}

type Query{}

type Mutation{}

type Subscription{}

type Query {
  #apis:ReturnType
  hello:String
  #api with arg
  greet(message:String):String
  user:User
  customers:[Customer]
}

type Customer {
  id:ID
  name:String
}

type User{
 id:ID
 name:String
}

Client side 

query {
 user {
  id
  status
 }
}


type Mutation { 
 #apis
 createUser(user:User):User
 updateUser(id:ID,user:User):User
}

mutation CreateUser($user:User) {
  createUser(user:$user){
    id
    status
  }
....................................................................................
				 Data types In SDL
.....................................................................................

1.Scallar Types
   Scallar are like primitives types in the programming languages

1.Int - 32 Bit Signed Integer
2.String - UTF-8 
3.Boolean - true or false
4.Float - Signed Double
5.ID - String but Serialized string - For unique identification

2.Custom Types/Reference Types/ Object types
 Similar to classes in object oriented languages like java,C++,C#

type User {
 id:Int
 firstName:String
 lastName:String
 status:Boolean
 points:Float
}

Object can have other Object Type:
..................................
  Like has a relationship / Dependency injection

type Address { 
 city:String
 state:String
 country:String
}

type User {
 id:Int
 firstName:String
 lastName:String
 status:Boolean
 points:Float
 address:Address
}

Client side 

query {
 user {
  id
  status
  address  {
    city
  }
 }
}

....................................................................................
			Handling null and not null values
....................................................................................

Client query with data

query {
  user {
    name    ------------------> response {name:'Subramanian'}
  }
}

Client query without data

query {
  user {
    name    ------------------> response {name:null}
  }
}

Client is expecting that dont want to include null, if server null , i have to throw an exception.
 =>Not null field

Syntax:
   fieldName:Type!

! -Not Null
type Address { 
 city:String
 state:String
 country:String
}

type User {
 id:Int!
 firstName:String!
 lastName:String!
 status:Boolean
 points:Float
 address:Address
}

Here, id ,firstName,lastName cant be null, if there is null value, the server will throw exception.

....................................................................................
				Collections - List of similar values
....................................................................................
The field may have more values

 fieldName:[DataType]

Data Type could be scallar or Object Type

eg:
  products:[Product]
  users:[User]
  skills:[String]
.....................................................................................
			 Collections and Not Null
.....................................................................................
 [{id:1,name:'33'},{id:2,name:'test'},null,{id:3,name:'test'} ]

 languages:[Language!] - Language cant null  [user,,user,null,]

 languages:[Language]! - Array cant null languages:null

 languages:[Language!]! - Language and Array cant be null
......................................................................................
.....................................................................................
				Advanced Types
.....................................................................................

=>Mutation
=>Subscription
=>Input
=>Enum
=>Union
=>Interface

Mutation:
 For Add,update,delete operations

type Mutation {
  createUser(id:ID,firstName:String,lastName:String,age:Int):User
  updatUser(id:ID,user:User):User
  removeUser(id:ID):User
}
...................................................................................
                         Input
...................................................................................
Input type are special object type that allow you to provide hierachial data as args to fields

type Mutation {
  createUser(id:ID,firstName:String,lastName:String,age:Int):User
}

In the above code you can we have passed indivual fields, which is not going to be good.

Can i pass user type

type User {
 id:ID
 firstName:String
 lastName:String
 age:Int
}
type Mutation {
  createUser(user:User):User
}

Instead of passing User type, graphql offers special object type input

input CreateUserInput {
 id:ID
 firstName:String
 lastName:String
 age:Int
}

type Mutation {
  createUser(user:CreateUserInput):User
}
.....................................................................................
			 Enums
.....................................................................................

An Enum is similar to scalar type, but its leagal values are defined in the schema

enum Gender {
 MALE
 FEMALE
 THIRD
}

type Query {
 gender:Gender
}
.....................................................................................				Union and Interfaces
.....................................................................................
Unions and interfaces are abstract Graphql types that enables a schema field to return one of the multiple object types.

union Media = Image | Video

type Query {
  getMedia:[Media]
}

Note:
  Union type must be only object types not scalar or input types.
....................................................................................
			Interfaces
.....................................................................................

Interface Represents common fields that multiple objects can include

interface Book {
  title:String
  author:String
}
type GraphQLBook implements Book {
  title:String
  author:String 
  X:String  
}

type StoryBook implements Book {
  title:String
  author:String 
  Y:String  
}

Client Side:

Syntax : 1
query GetBooks {
   books {
      author
      title
    }
}
Here it returns all data,

What if i want Graphqlbook and storybook details 

query GetBooks {
  
   __typename
   title
   author
   ....on GraphQLBook {
      X
   }
   ....on StoryBook {
      Y
   }
}
...................................................................................
			   Custom Scalar types
...................................................................................
Graphql provides custom scalar types. 
I want Date,Time

How to define custom scallar?

scalar Date

type User {
  dob:Date
}

Here Date is custom scalar but this data type is represented / logic of this type is provided through "Server side code".
....................................................................................
			 Graphql Application dev
...................................................................................

You can write code in any language.

Java:
1.graphql-java
2.SpringBoot with Graphql
3.DGS Framework-Netflix
etc...

Javascript:

1.graphql-js.js
The JavaScript reference implementation for GraphQL, a query language for APIs created by Facebook.


2.Apollo
  It is platform for building enterprise graphql apps
  The core of Apollo framework is written on the graphql.js and express.js

Graphql application can be built using two arch
 1.monolith arch
 2.Microservices arch.

Apollo Core concepts:

  SuperGraph:
      Collection of small graphs called subgraph
      A unified network of your organizations microservices and their datasources
      -All Composed into a single distributed API.

  SubGraph:
      It represents a single Graph application

  Graph OS:
     It is cloud platform which hosts supergraph and router

   Router :
      It is compostion api , clients will communicate only Router
     Router internally stiches the schema for data reterival.

Components of Apollo:
.....................
1.Apollo Server : node js server written in express.js
2.Schema defintions - SDL
3.Resolvers - Schema Implementations like queries,mutations,subscription
4.Data Sources -  Database,rest api, any other apis.

Apollo code can be written in "javascript or typescript".
.....................................................................................
				Apollo Project setup
....................................................................................

Required Softwares:

1.node.js latest version
2.vscode

Project setup :

Step 1:
G:\Wipro\frontend>mkdir apollo-gettingstarted

Step 2:
G:\Wipro\frontend>cd apollo-gettingstarted

G:\Wipro\frontend\apollo-gettingstarted>npm init --yes
Wrote to G:\Wipro\frontend\apollo-gettingstarted\package.json:

{
  "name": "apollo-gettingstarted",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": ""
}

Step 3:
G:\Wipro\frontend\apollo-gettingstarted>code .

Step 4:install apollo server dependencies

npm install @apollo/server graphql

Step 5: install type script dependencies

npm i --save-dev typescript @types/node

  "dependencies": {
    "@apollo/server": "^4.10.5",
    "graphql": "^16.9.0"
  },
  "devDependencies": {
    "@types/node": "^20.14.12",
    "typescript": "^5.5.4"
  }

script:
In order to compile and run dev server in watch mode.

npm install --save-dev tsc-watch

package.json
  "scripts": {
    "start": "tsc-watch --onSuccess \"node ./dist/index.js"
  },



Lets verify settings:

src/index.ts
 console.log('Hello GraphQL')

G:\Wipro\frontend\apollo-gettingstarted>npm start

SDL implementation:

Steps:

1.Define schema
2.Write biz logic for schema - Resolver
3.Start Apollo Server


Define schema:

There is two to define schema in apollo
1.inside code 
2.outside code as separate file.

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `
 #Define api
 type Query{
   hello:String    
 } 

`
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        hello() {
            return "Hello Graphql"
        }
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Client code:
query HelloQuery {
  hello
}

Response:
{
  "data": {
    "hello": "Hello Graphql"
  }
}

How to connect this in React?
............................
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'
import { ApolloClient, InMemoryCache, ApolloProvider, gql, useQuery } from '@apollo/client'

const uri = 'http://localhost:4000/'
const client = new ApolloClient({
    uri: uri,
    cache: new InMemoryCache()
})

//declare the query
const GET_HELLO = gql`
query HELLOQuery {
  hello
}
 `
//Hello Component
function Hello() {
    const { loading, error, data } = useQuery(GET_HELLO)

    if (loading) return <p>Loading....</p>
    if (error) return <p>Error:{error.message}</p>
    console.log(data)
    return <>
        <h1>{data.hello}</h1>
    </>

}
const App = () => {
    return <>
        <Hello />
    </>
}

ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <ApolloProvider client={client}>
            <App />
        </ApolloProvider>
    </React.StrictMode>,
)

.....................................................................................	
				Descriptions(docStrings)
.....................................................................................
Graphql schema definitions supports markdown enabled documentation strings called "descriptions"

This helps consumers of your graph discover fields and learn how to use them.

""Comments"" => single line comment
"""
 Multi line comment => Multi line
"""

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `
 #Define api
 type Query{
   """
    This is hello api which returns Hello Grapql Message
   """
   hello:String    
 } 

`
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        hello() {
            return "Hello Graphql"
        }
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

....................................................................................
			  Default Resolvers
....................................................................................

if you define query in the schema defintion, if you dont define resolver, the Apollo provides default Resolver which always returns null.

Eg:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `
 #Define api
 type Query{
   hello:String    
 } 

`
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
       
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)
/////////

....................................................................................
			  Default Resolvers
....................................................................................

if you define query in the schema defintion, if you dont define resolver, the Apollo provides default Resolver which always returns null.

Eg:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `
 #Define api
 type Query{
   hello:String    
 } 

`
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
       
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client Side:
query HelloQuery {
  hello
}

Response:
{
  "data": {
    "hello": null
  }
}
.....................................................................................
			  Multiple apis
....................................................................................

You can multiple apis in the schema 
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `
 #Define api
 type Query{
    add:Int
    multiply:Int
    div:Int
} 

`
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        add() {
            return 10 + 10
        },
        multiply() {
            return 10 * 10
        },
        div() {
            return 10 / 2
        }

    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client Side:
query Add {
  add
}

query Multi {
  multiply
}

query Div {
  div
}

Response:
{
  "data": {
    "add": 20
  }
}
.....................................................................................
			 Object Types And Queries
.....................................................................................

Eg:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `

type User {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
}

type Query{
   user:User
} 

`
//Mock user data
const user = {
    id: 1,
    firstName: 'Subramanian',
    lastName: 'Murugan',
    age: 43,
    points: 1000,
    status: true
}

//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        user() {
            return user 
        }
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client Side:
query UserInfo {
  user {
    id
    firstName
    lastName    
    status
    points
  }
}
Response:

{
  "data": {
    "user": {
      "id": "1",
      "firstName": "Subramanian",
      "lastName": "Murugan",
      "status": true,
      "points": 1000
    }
  }
}


React Implementation:

Math:
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'
import { ApolloClient, InMemoryCache, ApolloProvider, gql, useQuery } from '@apollo/client'

const uri = 'http://localhost:4000/'
const client = new ApolloClient({
    uri: uri,
    cache: new InMemoryCache()
})

//declare the query
const GET_HELLO = gql`
query HELLOQuery {
  hello
}
 `
const MATH_QUERY = gql`
query AddQuery {
  add
  multiply
  div
}
  `

function Add() {
    const { loading, error, data } = useQuery(MATH_QUERY)

    if (loading) return <p>Loading....</p>
    if (error) return <p>Error:{error.message}</p>
    console.log(data)
    return <>
        <h1>{data.add} {data.multiply} {data.div}</h1>
    </>
}
const App = () => {
    return <>
        <Add/>
    </>
}

ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <ApolloProvider client={client}>
            <App />
        </ApolloProvider>
    </React.StrictMode>,
)

Object type:
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'
import { ApolloClient, InMemoryCache, ApolloProvider, gql, useQuery } from '@apollo/client'

const uri = 'http://localhost:4000/'
const client = new ApolloClient({
    uri: uri,
    cache: new InMemoryCache()
})


const USER_QUERY = gql`
query USER_QUERY {
  user {
    id
    firstName
    lastName
    age
    status
    points
  }
}
  `

function User() {
    const { loading, error, data } = useQuery(USER_QUERY)


    if (loading) return <p>Loading....</p>
    if (error) return <p>Error:{error.message}</p>
    console.log(data)
    return <>
        <h1>{data.user.id} {data.user.firstName} {data.user.lastName}</h1>
    </>
}
const App = () => {
    return <>
        <User/>
    </>
}

ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <ApolloProvider client={client}>
            <App />
        </ApolloProvider>
    </React.StrictMode>,
)

..
....................................................................................
				Collections
....................................................................................

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `

type User {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
}

type Query {
   users:[User]
} 

`
//Mock user data
const users = [{
    id: 1,
    firstName: 'Subramanian',
    lastName: 'Murugan',
    age: 43,
    points: 1000,
    status: true
},
{
    id: 2,
    firstName: 'Geetha',
    lastName: 'Subramanian',
    age: 40,
    points: 5000,
    status: true
},
{
    id: 3,
    firstName: 'Ram',
    lastName: 'M',
    age: 30,
    points: 5000,
    status: false
}

]

//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        users() {
            return users
        }
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Client:
query UserInfo {
  users {
    id
    firstName
    lastName    
    status
    points
  }
}

Response:
{
  "data": {
    "users": [
      {
        "id": "1",
        "firstName": "Subramanian",
        "lastName": "Murugan",
        "status": true,
        "points": 1000
      },
      {
        "id": "2",
        "firstName": "Geetha",
        "lastName": "Subramanian",
        "status": true,
        "points": 5000
      },
      {
        "id": "3",
        "firstName": "Ram",
        "lastName": "M",
        "status": false,
        "points": 5000
      }
    ]
  }
}

React:
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'
import { ApolloClient, InMemoryCache, ApolloProvider, gql, useQuery } from '@apollo/client'

const uri = 'http://localhost:4000/'
const client = new ApolloClient({
    uri: uri,
    cache: new InMemoryCache()
})


const USERS_QUERY = gql`
query USERS_QUERY {
  users {
    id
    firstName
    lastName
    age
    status
    points
  }
}
  `

function Users() {
    const { loading, error, data } = useQuery(USERS_QUERY)


    if (loading) return <p>Loading....</p>
    if (error) return <p>Error:{error.message}</p>
    console.log(data)
    return <>
        <div>
            {data.users.map(user => {
                return <h1>{user.id} {user.firstName} {user.lastName}</h1>
            })}
        </div>
    </>
}
const App = () => {
    return <>
        <Users />
    </>
}

ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <ApolloProvider client={client}>
            <App />
        </ApolloProvider>
    </React.StrictMode>,
)


Client Side:
query HelloQuery {
  hello
}

Response:
{
  "data": {
    "hello": null
  }
}
.....................................................................................
...................................................................................
			 Null and Not Null
...................................................................................
How to handle null and not null?

Without Null: with data

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type User {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
}

type Query {
    user:User
}


`
const resolvers = {
    Query: {
        user() {
            return {
                id: 1,
                firstName: 'Subramanian',
                lastName: 'Murugan',
                age: 43,
                points: 100,
                status: false
            }
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Query:
query UserInfo {
  user {
    id
    firstName
  }
}

Response:
{
  "data": {
    "user": {
      "id": "1",
      "firstName": "Subramanian"
    }
  }
}
.................................................................................

With null:

const resolvers = {
    Query: {
        user() {
               return null;
        }
    },

}
Response:
{
  "data": {
    "user": null
  }
}
i dont want null, my api must always return data.

type Query {
    user:User!
}
Here "user" api must return data, if you return null 

Server will throw "Exception"

{
  "data": {},
  "errors": [
    {
      "message": "Cannot return null for non-nullable field Query.user.",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ],
      "path": [
        "user"
      ],
}
...................................................................................
				Fields not Null.

Fields not Null:

type User {
    id:ID!
    firstName:String!
    lastName:String!
    age:Int
    points:Float
    status:Boolean
}

const resolvers = {
    Query: {
        user() {
            return {
                firstName: 'Subramanian',
                lastName: 'Murugan',
                age: 43,
                points: 100,
                status: false
            }
        }
    },

}
Here "id" is missing, so the server will throw exception

{
  "data": {},
  "errors": [
    {
      "message": "Cannot return null for non-nullable field User.id.",
      "locations": [
        {
          "line": 3,
          "column": 5
        }
      ]
}
...................................................................................
			 Collections and null
....................................................................................

Syntax:
  products:[Product!]
  products:[Product]!
  products:[Product!]!


products:[Product!]:
...................
products:null -valid
products:[] - empty array -valid
products:[{id:1}] - arrays with data - valid
products:[null]

eg:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type User {
    id:ID!
    firstName:String!
    lastName:String!
    age:Int
    points:Float
    status:Boolean
}

type Query {
    users:[User!]
}


`
const resolvers = {
    Query: {
        users() {
            // return [{
            //     id:1,
            //     firstName: 'Subramanian',
            //     lastName: 'Murugan',
            //     age: 43,
            //     points: 100,
            //     status: false
            // }]
           // return null;
           return [null]
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Query:
query UserInfo {
  users {
    id
    firstName
    lastName
    status
    points
  }
}

Response:

  "data": {
    "users": null
  },
  "errors": [
    {
      "message": "Cannot return null for non-nullable field Query.users.",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ]
}
.....................................................................................

products:[String]!

Empty Array:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type Query {
    skills:[String]!
}
`
const resolvers = {
    Query: {
        skills() {
            return []
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Client Side:
query Skills {
  skills
}

Response:
{
  "data": {
    "skills": []
  }
}

With data:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type Query {
    skills:[String]!
}
`
const resolvers = {
    Query: {
        skills() {
            
            return ['Graphql']
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client Side:
query Skills {
  skills
}

Response:
{
  "data": {
    "skills": [
      "Graphql"
    ]
  }
}

With Null
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type Query {
    skills:[String]!
}
`
const resolvers = {
    Query: {
        skills() {
               return null 
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Client Side:
query Skills {
  skills
}


Response:
{
  "data": {},
  "errors": [
    {
      "message": "Cannot return null for non-nullable field Query.skills.",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ],
      "path": [
        "skills"
      ],
}


Inside Null: vaild
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type Query {
    skills:[String]!
}
`
const resolvers = {
    Query: {
        skills() {
               return [null]
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client Side:
query Skills {
  skills
}

Response:
{
  "data": {
    "skills": [
      null
    ]
  }
}
.....................................................................................

skills:[String!]!

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type Query {
    skills:[String!]!
}
`
const resolvers = {
    Query: {
        skills() {
              //return [null]
              //return null
              return []
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client side:

query Skills {
  skills
}

Response:
{
  "data": {},
  "errors": [
    {
      "message": "Cannot return null for non-nullable field Query.skills.",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ],
      "path": [
        "skills"
      ],
}
.....................................................................................

