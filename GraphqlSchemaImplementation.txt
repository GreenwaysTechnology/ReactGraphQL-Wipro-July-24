 			  Graphql API Implementation
.....................................................................................
In order to build apis we have many technologies

1.REST
2.Graphql
3.Grpc

How to build REST apis?

  Restfull webservices are built based on "Resources" in the Problem Domain.

Resources are represented by "Object" which expose Data.

Eg:
 CustomerResource,OrderResource,PaymentResource,CourseResource

Resources are identified by "URL" 
  => /api/customers GET | POST | DELETE | UPDATE

In Graphql apps are built based on "Models" Which are objects

What ever language we have to think in terms of Objects
...................................................................................
Graphql Schema Language                         Programming Langauge
....................................................................................
  Schema                                        class or Object

  Customer                                      class Customer {} | let Customer={}

Object shape is described by "Schema". 

Schema is nothing but "Plan"

In Graphql context, the "Problem domain"  is represented by "Schema language"
....................................................................................
			SDL - Schema Definition Language
....................................................................................
SDL Core concepts:
..................

1.Type System:
...............
   The Type system defines the platform and language independant data types which describe what data can be quried by client.

Schema Type Systems =============================>Programming language Type System
eg:
   String           =============================>javascript -string

    Int             ==============================>javascript -number

Client                                        Server

 Query ----|SDL-----send request --------    |SDL---Models--->Bizlogic(services|							 resolvers)-->Datasources

					  |---->java,kotlin,scala,c#,python -jvm
					  |---->js,typescript -node
			SDL implementation|---->
					  |---->
					
	

How to start with SDL?

we need to define type.

syntax:
 type TypeName{
    field:Type
 }
IN SDL, there is root type, every type is dervied from the root type.

type Schema {
  query:Query
  mutation:Mutation
  subscription:Subscription
}

type Query{}

type Mutation{}

type Subscription{}

type Query {
  #apis:ReturnType
  hello:String
  #api with arg
  greet(message:String):String
  user:User
  customers:[Customer]
}

type Customer {
  id:ID
  name:String
}

type User{
 id:ID
 name:String
}

Client side 

query {
 user {
  id
  status
 }
}


type Mutation { 
 #apis
 createUser(user:User):User
 updateUser(id:ID,user:User):User
}

mutation CreateUser($user:User) {
  createUser(user:$user){
    id
    status
  }
....................................................................................
				 Data types In SDL
.....................................................................................

1.Scallar Types
   Scallar are like primitives types in the programming languages

1.Int - 32 Bit Signed Integer
2.String - UTF-8 
3.Boolean - true or false
4.Float - Signed Double
5.ID - String but Serialized string - For unique identification

2.Custom Types/Reference Types/ Object types
 Similar to classes in object oriented languages like java,C++,C#

type User {
 id:Int
 firstName:String
 lastName:String
 status:Boolean
 points:Float
}

Object can have other Object Type:
..................................
  Like has a relationship / Dependency injection

type Address { 
 city:String
 state:String
 country:String
}

type User {
 id:Int
 firstName:String
 lastName:String
 status:Boolean
 points:Float
 address:Address
}

Client side 

query {
 user {
  id
  status
  address  {
    city
  }
 }
}

....................................................................................
			Handling null and not null values
....................................................................................

Client query with data

query {
  user {
    name    ------------------> response {name:'Subramanian'}
  }
}

Client query without data

query {
  user {
    name    ------------------> response {name:null}
  }
}

Client is expecting that dont want to include null, if server null , i have to throw an exception.
 =>Not null field

Syntax:
   fieldName:Type!

! -Not Null
type Address { 
 city:String
 state:String
 country:String
}

type User {
 id:Int!
 firstName:String!
 lastName:String!
 status:Boolean
 points:Float
 address:Address
}

Here, id ,firstName,lastName cant be null, if there is null value, the server will throw exception.

....................................................................................
				Collections - List of similar values
....................................................................................
The field may have more values

 fieldName:[DataType]

Data Type could be scallar or Object Type

eg:
  products:[Product]
  users:[User]
  skills:[String]
.....................................................................................
			 Collections and Not Null
.....................................................................................
 [{id:1,name:'33'},{id:2,name:'test'},null,{id:3,name:'test'} ]

 languages:[Language!] - Language cant null  [user,,user,null,]

 languages:[Language]! - Array cant null languages:null

 languages:[Language!]! - Language and Array cant be null
......................................................................................
.....................................................................................
				Advanced Types
.....................................................................................

=>Mutation
=>Subscription
=>Input
=>Enum
=>Union
=>Interface

Mutation:
 For Add,update,delete operations

type Mutation {
  createUser(id:ID,firstName:String,lastName:String,age:Int):User
  updatUser(id:ID,user:User):User
  removeUser(id:ID):User
}
...................................................................................
                         Input
...................................................................................
Input type are special object type that allow you to provide hierachial data as args to fields

type Mutation {
  createUser(id:ID,firstName:String,lastName:String,age:Int):User
}

In the above code you can we have passed indivual fields, which is not going to be good.

Can i pass user type

type User {
 id:ID
 firstName:String
 lastName:String
 age:Int
}
type Mutation {
  createUser(user:User):User
}

Instead of passing User type, graphql offers special object type input

input CreateUserInput {
 id:ID
 firstName:String
 lastName:String
 age:Int
}

type Mutation {
  createUser(user:CreateUserInput):User
}
.....................................................................................
			 Enums
.....................................................................................

An Enum is similar to scalar type, but its leagal values are defined in the schema

enum Gender {
 MALE
 FEMALE
 THIRD
}

type Query {
 gender:Gender
}
.....................................................................................				Union and Interfaces
.....................................................................................
Unions and interfaces are abstract Graphql types that enables a schema field to return one of the multiple object types.

union Media = Image | Video

type Query {
  getMedia:[Media]
}

Note:
  Union type must be only object types not scalar or input types.
....................................................................................
			Interfaces
.....................................................................................

Interface Represents common fields that multiple objects can include

interface Book {
  title:String
  author:String
}
type GraphQLBook implements Book {
  title:String
  author:String 
  X:String  
}

type StoryBook implements Book {
  title:String
  author:String 
  Y:String  
}

Client Side:

Syntax : 1
query GetBooks {
   books {
      author
      title
    }
}
Here it returns all data,

What if i want Graphqlbook and storybook details 

query GetBooks {
  
   __typename
   title
   author
   ....on GraphQLBook {
      X
   }
   ....on StoryBook {
      Y
   }
}
...................................................................................
			   Custom Scalar types
...................................................................................
Graphql provides custom scalar types. 
I want Date,Time

How to define custom scallar?

scalar Date

type User {
  dob:Date
}

Here Date is custom scalar but this data type is represented / logic of this type is provided through "Server side code".
....................................................................................
			 Graphql Application dev
...................................................................................

You can write code in any language.

Java:
1.graphql-java
2.SpringBoot with Graphql
3.DGS Framework-Netflix
etc...

Javascript:

1.graphql-js.js
The JavaScript reference implementation for GraphQL, a query language for APIs created by Facebook.


2.Apollo
  It is platform for building enterprise graphql apps
  The core of Apollo framework is written on the graphql.js and express.js

Graphql application can be built using two arch
 1.monolith arch
 2.Microservices arch.

Apollo Core concepts:

  SuperGraph:
      Collection of small graphs called subgraph
      A unified network of your organizations microservices and their datasources
      -All Composed into a single distributed API.

  SubGraph:
      It represents a single Graph application

  Graph OS:
     It is cloud platform which hosts supergraph and router

   Router :
      It is compostion api , clients will communicate only Router
     Router internally stiches the schema for data reterival.

Components of Apollo:
.....................
1.Apollo Server : node js server written in express.js
2.Schema defintions - SDL
3.Resolvers - Schema Implementations like queries,mutations,subscription
4.Data Sources -  Database,rest api, any other apis.

Apollo code can be written in "javascript or typescript".
.....................................................................................
				Apollo Project setup
....................................................................................

Required Softwares:

1.node.js latest version
2.vscode

Project setup :

Step 1:
G:\Wipro\frontend>mkdir apollo-gettingstarted

Step 2:
G:\Wipro\frontend>cd apollo-gettingstarted

G:\Wipro\frontend\apollo-gettingstarted>npm init --yes
Wrote to G:\Wipro\frontend\apollo-gettingstarted\package.json:

{
  "name": "apollo-gettingstarted",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": ""
}

Step 3:
G:\Wipro\frontend\apollo-gettingstarted>code .

Step 4:install apollo server dependencies

npm install @apollo/server graphql

Step 5: install type script dependencies

npm i --save-dev typescript @types/node

  "dependencies": {
    "@apollo/server": "^4.10.5",
    "graphql": "^16.9.0"
  },
  "devDependencies": {
    "@types/node": "^20.14.12",
    "typescript": "^5.5.4"
  }

script:
In order to compile and run dev server in watch mode.

npm install --save-dev tsc-watch

package.json
  "scripts": {
    "start": "tsc-watch --onSuccess \"node ./dist/index.js"
  },



Lets verify settings:

src/index.ts
 console.log('Hello GraphQL')

G:\Wipro\frontend\apollo-gettingstarted>npm start

SDL implementation:

Steps:

1.Define schema
2.Write biz logic for schema - Resolver
3.Start Apollo Server


Define schema:

There is two to define schema in apollo
1.inside code 
2.outside code as separate file.

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `
 #Define api
 type Query{
   hello:String    
 } 

`
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        hello() {
            return "Hello Graphql"
        }
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Client code:
query HelloQuery {
  hello
}

Response:
{
  "data": {
    "hello": "Hello Graphql"
  }
}

How to connect this in React?
............................
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'
import { ApolloClient, InMemoryCache, ApolloProvider, gql, useQuery } from '@apollo/client'

const uri = 'http://localhost:4000/'
const client = new ApolloClient({
    uri: uri,
    cache: new InMemoryCache()
})

//declare the query
const GET_HELLO = gql`
query HELLOQuery {
  hello
}
 `
//Hello Component
function Hello() {
    const { loading, error, data } = useQuery(GET_HELLO)

    if (loading) return <p>Loading....</p>
    if (error) return <p>Error:{error.message}</p>
    console.log(data)
    return <>
        <h1>{data.hello}</h1>
    </>

}
const App = () => {
    return <>
        <Hello />
    </>
}

ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <ApolloProvider client={client}>
            <App />
        </ApolloProvider>
    </React.StrictMode>,
)

.....................................................................................	
				Descriptions(docStrings)
.....................................................................................
Graphql schema definitions supports markdown enabled documentation strings called "descriptions"

This helps consumers of your graph discover fields and learn how to use them.

""Comments"" => single line comment
"""
 Multi line comment => Multi line
"""

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `
 #Define api
 type Query{
   """
    This is hello api which returns Hello Grapql Message
   """
   hello:String    
 } 

`
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        hello() {
            return "Hello Graphql"
        }
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

....................................................................................
			  Default Resolvers
....................................................................................

if you define query in the schema defintion, if you dont define resolver, the Apollo provides default Resolver which always returns null.

Eg:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `
 #Define api
 type Query{
   hello:String    
 } 

`
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
       
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)
/////////

....................................................................................
			  Default Resolvers
....................................................................................

if you define query in the schema defintion, if you dont define resolver, the Apollo provides default Resolver which always returns null.

Eg:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `
 #Define api
 type Query{
   hello:String    
 } 

`
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
       
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client Side:
query HelloQuery {
  hello
}

Response:
{
  "data": {
    "hello": null
  }
}
.....................................................................................
			  Multiple apis
....................................................................................

You can multiple apis in the schema 
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `
 #Define api
 type Query{
    add:Int
    multiply:Int
    div:Int
} 

`
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        add() {
            return 10 + 10
        },
        multiply() {
            return 10 * 10
        },
        div() {
            return 10 / 2
        }

    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client Side:
query Add {
  add
}

query Multi {
  multiply
}

query Div {
  div
}

Response:
{
  "data": {
    "add": 20
  }
}
.....................................................................................
			 Object Types And Queries
.....................................................................................

Eg:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `

type User {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
}

type Query{
   user:User
} 

`
//Mock user data
const user = {
    id: 1,
    firstName: 'Subramanian',
    lastName: 'Murugan',
    age: 43,
    points: 1000,
    status: true
}

//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        user() {
            return user 
        }
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client Side:
query UserInfo {
  user {
    id
    firstName
    lastName    
    status
    points
  }
}
Response:

{
  "data": {
    "user": {
      "id": "1",
      "firstName": "Subramanian",
      "lastName": "Murugan",
      "status": true,
      "points": 1000
    }
  }
}


React Implementation:

Math:
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'
import { ApolloClient, InMemoryCache, ApolloProvider, gql, useQuery } from '@apollo/client'

const uri = 'http://localhost:4000/'
const client = new ApolloClient({
    uri: uri,
    cache: new InMemoryCache()
})

//declare the query
const GET_HELLO = gql`
query HELLOQuery {
  hello
}
 `
const MATH_QUERY = gql`
query AddQuery {
  add
  multiply
  div
}
  `

function Add() {
    const { loading, error, data } = useQuery(MATH_QUERY)

    if (loading) return <p>Loading....</p>
    if (error) return <p>Error:{error.message}</p>
    console.log(data)
    return <>
        <h1>{data.add} {data.multiply} {data.div}</h1>
    </>
}
const App = () => {
    return <>
        <Add/>
    </>
}

ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <ApolloProvider client={client}>
            <App />
        </ApolloProvider>
    </React.StrictMode>,
)

Object type:
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'
import { ApolloClient, InMemoryCache, ApolloProvider, gql, useQuery } from '@apollo/client'

const uri = 'http://localhost:4000/'
const client = new ApolloClient({
    uri: uri,
    cache: new InMemoryCache()
})


const USER_QUERY = gql`
query USER_QUERY {
  user {
    id
    firstName
    lastName
    age
    status
    points
  }
}
  `

function User() {
    const { loading, error, data } = useQuery(USER_QUERY)


    if (loading) return <p>Loading....</p>
    if (error) return <p>Error:{error.message}</p>
    console.log(data)
    return <>
        <h1>{data.user.id} {data.user.firstName} {data.user.lastName}</h1>
    </>
}
const App = () => {
    return <>
        <User/>
    </>
}

ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <ApolloProvider client={client}>
            <App />
        </ApolloProvider>
    </React.StrictMode>,
)

..
....................................................................................
				Collections
....................................................................................

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `

type User {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
}

type Query {
   users:[User]
} 

`
//Mock user data
const users = [{
    id: 1,
    firstName: 'Subramanian',
    lastName: 'Murugan',
    age: 43,
    points: 1000,
    status: true
},
{
    id: 2,
    firstName: 'Geetha',
    lastName: 'Subramanian',
    age: 40,
    points: 5000,
    status: true
},
{
    id: 3,
    firstName: 'Ram',
    lastName: 'M',
    age: 30,
    points: 5000,
    status: false
}

]

//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        users() {
            return users
        }
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Client:
query UserInfo {
  users {
    id
    firstName
    lastName    
    status
    points
  }
}

Response:
{
  "data": {
    "users": [
      {
        "id": "1",
        "firstName": "Subramanian",
        "lastName": "Murugan",
        "status": true,
        "points": 1000
      },
      {
        "id": "2",
        "firstName": "Geetha",
        "lastName": "Subramanian",
        "status": true,
        "points": 5000
      },
      {
        "id": "3",
        "firstName": "Ram",
        "lastName": "M",
        "status": false,
        "points": 5000
      }
    ]
  }
}

React:
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'
import { ApolloClient, InMemoryCache, ApolloProvider, gql, useQuery } from '@apollo/client'

const uri = 'http://localhost:4000/'
const client = new ApolloClient({
    uri: uri,
    cache: new InMemoryCache()
})


const USERS_QUERY = gql`
query USERS_QUERY {
  users {
    id
    firstName
    lastName
    age
    status
    points
  }
}
  `

function Users() {
    const { loading, error, data } = useQuery(USERS_QUERY)


    if (loading) return <p>Loading....</p>
    if (error) return <p>Error:{error.message}</p>
    console.log(data)
    return <>
        <div>
            {data.users.map(user => {
                return <h1>{user.id} {user.firstName} {user.lastName}</h1>
            })}
        </div>
    </>
}
const App = () => {
    return <>
        <Users />
    </>
}

ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <ApolloProvider client={client}>
            <App />
        </ApolloProvider>
    </React.StrictMode>,
)


Client Side:
query HelloQuery {
  hello
}

Response:
{
  "data": {
    "hello": null
  }
}
.....................................................................................
...................................................................................
			 Null and Not Null
...................................................................................
How to handle null and not null?

Without Null: with data

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type User {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
}

type Query {
    user:User
}


`
const resolvers = {
    Query: {
        user() {
            return {
                id: 1,
                firstName: 'Subramanian',
                lastName: 'Murugan',
                age: 43,
                points: 100,
                status: false
            }
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Query:
query UserInfo {
  user {
    id
    firstName
  }
}

Response:
{
  "data": {
    "user": {
      "id": "1",
      "firstName": "Subramanian"
    }
  }
}
.................................................................................

With null:

const resolvers = {
    Query: {
        user() {
               return null;
        }
    },

}
Response:
{
  "data": {
    "user": null
  }
}
i dont want null, my api must always return data.

type Query {
    user:User!
}
Here "user" api must return data, if you return null 

Server will throw "Exception"

{
  "data": {},
  "errors": [
    {
      "message": "Cannot return null for non-nullable field Query.user.",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ],
      "path": [
        "user"
      ],
}
...................................................................................
				Fields not Null.

Fields not Null:

type User {
    id:ID!
    firstName:String!
    lastName:String!
    age:Int
    points:Float
    status:Boolean
}

const resolvers = {
    Query: {
        user() {
            return {
                firstName: 'Subramanian',
                lastName: 'Murugan',
                age: 43,
                points: 100,
                status: false
            }
        }
    },

}
Here "id" is missing, so the server will throw exception

{
  "data": {},
  "errors": [
    {
      "message": "Cannot return null for non-nullable field User.id.",
      "locations": [
        {
          "line": 3,
          "column": 5
        }
      ]
}
...................................................................................
			 Collections and null
....................................................................................

Syntax:
  products:[Product!]
  products:[Product]!
  products:[Product!]!


products:[Product!]:
...................
products:null -valid
products:[] - empty array -valid
products:[{id:1}] - arrays with data - valid
products:[null]

eg:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type User {
    id:ID!
    firstName:String!
    lastName:String!
    age:Int
    points:Float
    status:Boolean
}

type Query {
    users:[User!]
}


`
const resolvers = {
    Query: {
        users() {
            // return [{
            //     id:1,
            //     firstName: 'Subramanian',
            //     lastName: 'Murugan',
            //     age: 43,
            //     points: 100,
            //     status: false
            // }]
           // return null;
           return [null]
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Query:
query UserInfo {
  users {
    id
    firstName
    lastName
    status
    points
  }
}

Response:

  "data": {
    "users": null
  },
  "errors": [
    {
      "message": "Cannot return null for non-nullable field Query.users.",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ]
}
.....................................................................................

products:[String]!

Empty Array:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type Query {
    skills:[String]!
}
`
const resolvers = {
    Query: {
        skills() {
            return []
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Client Side:
query Skills {
  skills
}

Response:
{
  "data": {
    "skills": []
  }
}

With data:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type Query {
    skills:[String]!
}
`
const resolvers = {
    Query: {
        skills() {
            
            return ['Graphql']
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client Side:
query Skills {
  skills
}

Response:
{
  "data": {
    "skills": [
      "Graphql"
    ]
  }
}

With Null
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type Query {
    skills:[String]!
}
`
const resolvers = {
    Query: {
        skills() {
               return null 
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Client Side:
query Skills {
  skills
}


Response:
{
  "data": {},
  "errors": [
    {
      "message": "Cannot return null for non-nullable field Query.skills.",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ],
      "path": [
        "skills"
      ],
}


Inside Null: vaild
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type Query {
    skills:[String]!
}
`
const resolvers = {
    Query: {
        skills() {
               return [null]
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client Side:
query Skills {
  skills
}

Response:
{
  "data": {
    "skills": [
      null
    ]
  }
}
.....................................................................................

skills:[String!]!

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type Query {
    skills:[String!]!
}
`
const resolvers = {
    Query: {
        skills() {
              //return [null]
              //return null
              return []
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client side:

query Skills {
  skills
}

Response:
{
  "data": {},
  "errors": [
    {
      "message": "Cannot return null for non-nullable field Query.skills.",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ],
      "path": [
        "skills"
      ],
}

.....................................................................................
 		Mobile applications and Graphql Integration
.....................................................................................

Types of mobile Application

1.native mobile app
  app written in native technology like android,ios
2.hybrid mobile app
  app written in js.

React and Mobile Application:
.............................
   Using react we can create mobile apps called "react native application".

React native apps are written using "core react principles like componets,state,props"


React web vs react native:
...........................

react web uses html as mark up language
react native uses "Mobile markup language"

https://reactnative.dev/docs/set-up-your-environment?os=windows

Before that we need to have mobile environment.

I am going to emulator

Create React Native Project using react native cli:
..................................................

npx @react-native-community/cli@latest init GraphqlApp

User interface:
 in case of react we html as markup , but here we use mobile markup.

web       react native
<div>      <View>
h1,h2      <Text>


Styling:
 In react we use css language directly

 <div className="container">

 In react native we css via js 

 <View style={{backgroundColor:'pink'}} />

Layouts in web:

1.fixed width layout
2.Responsive layout using %
3.Responsive layout
   ->grid
   ->flex

Flex is layout by default used in React native

Props, state,functions,hooks every thing is same.

index.js is entry file
App.jsx is Root Application component



App.jsx
import { useState } from "react";
import { View, Text, StyleSheet, Button } from "react-native";

const Counter = () => {
    const [counter, setCounter] = useState(0)
    return <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
        <Text>Counter {counter}</Text>
        <Button title="+" onPress={() => {
            setCounter(counter + 1)
        }} />
    </View>
}

function App() {
    return <View style={styles.container}>
        <Text style={{ fontSize: 20 }}>Welcome To Graphql app!</Text>
        <Counter />
    </View>
}
export default App;

const styles = StyleSheet.create({
    container: {
        flex: 1,
        marginTop: 10,
        alignItems: 'center'
    }
})

How to connect ReactNative with graphql server?
...............................................

import { ApolloClient, InMemoryCache, ApolloProvider, gql, useQuery } from '@apollo/client'
import { View, Text, StyleSheet, Button, ScrollView } from "react-native";

const uri = 'https://countries.trevorblades.com/'
const client = new ApolloClient({
    uri: uri,
    cache: new InMemoryCache()
})


const COUNTRIES_QUERY = gql`
query COUNTRIES_QUERY {
  countries {
    name
  }
}

  `
const Countries = () => {
    const { loading, error, data } = useQuery(COUNTRIES_QUERY)
    if (loading) return <Text>Loading....</Text>
    if (error) return <Text>Error:{error.message}</Text>

    return <ScrollView style={styles.container}>
        <>
                {data.countries.map(country => {
                    return <Text style={{textAlign:'center',color:'blue'}}>{country.name}</Text>
                })}
        </>
    </ScrollView>
}

function App() {
    return <ApolloProvider client={client}>
        <Countries/>
    </ApolloProvider>
}
export default App;

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: 'pink'
    }
})
...................................................................................
			   Mutation
...................................................................................

Mutation means sending data for insert,update,delete

In the React.

useMutation react hook is the primary api for executing mutations in an apollo application.

Syntax:

import {gql,useMutation} from '@apollo/client'

//Define mutation:
const NAME_MUTATION = gql`

 mutation save {
     fields
 }


`
function MyComponent(){
 const [mutateFunction,{data,loading,error}]=useMutation(NAME_MUTATION)
}

useMutation hooks returns "tuple" that includes

1.A mutation function that you can call at any time to execute the mutation
 
2.Unlike useQuery, useMutation does not execute its operations automatically on render,instead , you call this mutation function in the button click.

3.An object with fields that the represent the current status of the muation's
  excution - data,loding,error etc...


Eg:
 we are going to create simple todo application, and we want to the user to be able to add items to their list.

Server side code

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'
import { LRUCache } from "lru-cache"
//type defs
const typeDefs = `
  type Query {
     todos:[Todo],
     todo(id:String!):Todo
  }
  type Todo{
   id:ID!
   title:String
   completed:Boolean
  }
  type Mutation {
   addTodo(title:String!,completed:Boolean):Todo
   updateTodo(id:String!,title:String!):Todo
  }

`
const todosItem = [{
    id: 1,
    title: "delectus aut autem",
    completed: false
},
{
    id: 2,
    title: "quis ut nam facilis et officia qui",
    completed: false
},]
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        todos() {
            return todosItem
        }
    },
    //Mutation

    Mutation: {
        addTodo(_, { title, completed }) {
            const newTodo = { id: 2 + 2, title, completed }
            //write a logic to push newtodo into array
            todosItem.concat(newTodo)
            console.log(todosItem)
            return newTodo
        }
    }
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

React code:
............

import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'
import { ApolloClient, InMemoryCache, ApolloProvider, gql, useQuery, useMutation } from '@apollo/client'

const uri = 'http://localhost:4000/'
const client = new ApolloClient({
    uri: uri,
    cache: new InMemoryCache()
})


const TODO_MUTATION = gql`
  mutation CREATE_TODO($title:String!,$completed:Boolean=false) {
    addTodo(title:$title,completed:$completed){
       id
       title
       completed
    }
}

 `

function Todo() {
    let title;
    let completed;
    const [addTodo, { data, loading, error }] = useMutation(TODO_MUTATION)
    if (loading) return 'Submitting'
    if (error) return `Submssion eror! ${error.message}`
    if(data){
        return <h1>{JSON.stringify(data)}</h1>
    }
    return <div>
        <form onSubmit={e => {
            e.preventDefault()
            addTodo({ variables: { title: title.value, completed: false } })
        }}>
            <input ref={node => {
                title = node
            }} />
            <button type="submit">Add Todo</button>
        </form>
    </div>
}
const App = () => {
    return <>
        <Todo />
    </>
}

ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <ApolloProvider client={client}>
            <App />
        </ApolloProvider>
    </React.StrictMode>,
)
.....................................................................................
			   Subscriptions
....................................................................................
Get real time updates from Graphql server.

Like queries , subscriptions enable you to fetch data.
Unlike queries, subscriptions are long lasting opertions that can change their result over period times.
They can maintain an active connection to your graphql server(over websocket)

Subscriptions are use full for notifying your client in real time about changes to back end data, such as creation of new object or updates an important field.

When to use Subscriptions:
..........................

In the majority of the use cases, your client should not use subscriptions to stay update with your back end.

How Subscriptions work?

Supported subscription protocals
................................
  The graphql spec does not define a specific protocal for sending subscriptions request.

1.WebSocket is one the protocal to send subscriptions to client

Sub protocals:
...............
  1.graphql-ws
  2.subscriptions-transport-ws - deprecated

2.HTTP, using chunked multipart responses 
 
Subprotocals for http
   1.Relay
   2.urql
....................................................................................

Defining Subscription
.....................

To define a subscription on the both server and client side, just like you do for quries and mutations.

Server side:

type Subscription{
   commentAdded(postID:ID!):Comment
}

"commentAdded" subscription notifies a subcribing client when ever a new comment is added to a particular blog post.

Client Side
............

const COMMENTS_SUBSCRIPTION = gql `
  subscription OnCommentAdded($postID:ID!){
     commentAdded(postID:$postID){
         id
         content
     }

  }

`
When apollo client executes the above subscription,, it establishes  a connection
to your graphql server and listens for response.

Unlike query, there is no expectation that the server will immediately process and return a response.

Only Your pushses data to your client when a particular "event" occurs on your backend


Server side code:

project setup:

mkdir subscriptions-server

G:\Wipro\frontend\subscriptions-server>npm init --yes
Wrote to G:\Wipro\frontend\subscriptions-server\package.json:

{
  "name": "subscriptions-server",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": ""
}
install core dependencies:
..........................
npm install @apollo/server graphql
npm i --save-dev typescript @types/node
npm install --save-dev tsc-watch

subscriptions related dependency

Websocket setup:

npm i graphql-ws

ApolloLink is lib that helps you customize Apollo client's network communication.

"GraphQLWSLink" is wrapper api to send messages over ws

import {GraphqlWSLink} from '@apollo/client/link/subscription'
import {createClient} from 'graphql-ws'


const wsLink=new GraphqlWSLink(createClient({
 url:'ws://localhost:4000/subscriptions'
}))

3.Spilt Communication by operations(Query,Mutation,Subscription)

 Although apollo client can use your GraphqlWSLink to exectue all operation types,
 in most cases it may contain using HTTP Queries and mutations.
 This is because queries and mutations does not require long lasting statefull  connections 

 In order to isloate @apollo/client lib provides spilt function that lets you isloate
 two different Links according to boolean checks.


const httpLink=new HttpLink({
 uri:'http://localost:4000/grapqhl'
})

const wsLink=new GraphqlWSLink(createClient({
 url:'ws://localhost:4000/subscriptions'
}))

const spilitLink = spilt(...)

const client = new ApolloClient({
  link:spiltLink,
  cache: new InMemoryCache()
})
.....................................................................................
			Setting up Subscription server
....................................................................................

schema:
// Schema definition

const typeDefs = `#graphql
  type Query {
    currentNumber: Int
  }

  type Subscription {
    numberIncremented: Int
  }
`;

Enabling subscriptions:
.......................

1.startStandaloneServer is not supported by Apollo Server when we use subscriptions

2.toEnble subscriptions, you must first swap using the "expressMiddleware" function

3.install the following dependencies

  npm i graphql-ws ws @graphql-tools-schema

import { createServer } from 'http';
import { ApolloServerPluginDrainHttpServer } from '@apollo/server/plugin/drainHttpServer';
import { makeExecutableSchema } from '@graphql-tools/schema';
import { WebSocketServer } from 'ws';
import { useServer } from 'graphql-ws/lib/use/ws';


4.schema and resolver binding

// A number that we'll increment over time to simulate subscription events
let currentNumber = 0;

// Schema definition
const typeDefs = `#graphql
  type Query {
    currentNumber: Int
  }

  type Subscription {
    numberIncremented: Int
  }
`;

// Resolver map
const resolvers = {
  Query: {
    currentNumber() {
      return currentNumber;
    },
  },
  Subscription: {
    numberIncremented: {
      subscribe: () => pubsub.asyncIterator(['NUMBER_INCREMENTED']),
    },
  },
};

// Create schema, which will be used separately by ApolloServer and
// the WebSocket server.
const schema = makeExecutableSchema({ typeDefs, resolvers });


Websocker setup:

const app = express();
const httpServer = createServer(app);

// Set up WebSocket server.
const wsServer = new WebSocketServer({
  server: httpServer,
  path: '/graphql',
});

Event Emission:
 Sending data to client via subscriptions
 
Subscriptions are based on pub-sub pattern (Event Driven Pattern).

Publisher(Server)
  Publishes event(data)

How to publish event:
....................

 There is special libraries available to publish event.

1.PubSub instance from 'graphql-subscriptions' package
 npm i graphql-subscriptions

Production grade PubSub libr
2.Kafka

3.redis

4.GooglePub
etc

Subscriber(Client)
  Listens for event(data)
 
Eg:

package.json
{
  "name": "as4-subscriptions-graphql-ws",
  "version": "1.0.0",
  "description": "An example of setting up subscriptions with Apollo Server 4",
  "main": "dist/index.js",
  "type": "module",
  "scripts": {
    "postinstall": "npm run compile",
    "compile": "tsc",
    "start": "npm run compile && node ./dist/index.js"
  },
  "license": "MIT",
  "dependencies": {
    "@apollo/server": "^4.1.0",
    "@graphql-tools/schema": "^9.0.13",
    "cors": "^2.8.5",
    "express": "^4.17.1",
    "graphql": "^16.6.0",
    "graphql-subscriptions": "^2.0.0",
    "graphql-ws": "^5.5.5",
    "typescript": "^4.7.4",
    "ws": "^8.4.2"
  },
  "devDependencies": {
    "@types/cors": "^2.8.13",
    "@types/node": "^18.6.3",
    "@types/ws": "^8.2.2"
  }
}
.................................................................................

import { ApolloServer } from '@apollo/server';
import { expressMiddleware } from '@apollo/server/express4';
import { ApolloServerPluginDrainHttpServer } from '@apollo/server/plugin/drainHttpServer';
import express from 'express';
import { createServer } from 'http';
import { makeExecutableSchema } from '@graphql-tools/schema';
import { WebSocketServer } from 'ws';
import { useServer } from 'graphql-ws/lib/use/ws';
import { PubSub } from 'graphql-subscriptions';
import bodyParser from 'body-parser';
import cors from 'cors';

const PORT = 4000;
const pubsub = new PubSub();

// A number that we'll increment over time to simulate subscription events
let currentNumber = 0;

// Schema definition
const typeDefs = `#graphql
  type Query {
    currentNumber: Int
  }

  type Subscription {
    numberIncremented: Int
  }
`;

// Resolver map
const resolvers = {
  Query: {
    currentNumber() {
      return currentNumber;
    },
  },
  Subscription: {
    numberIncremented: {
      //pubsub.publish()
      //it will return event/publish event
      subscribe: () => pubsub.asyncIterator(['NUMBER_INCREMENTED']),
    },
  },
};

// Create schema, which will be used separately by ApolloServer and
// the WebSocket server.
const schema = makeExecutableSchema({ typeDefs, resolvers });

// Create an Express app and HTTP server; we will attach the WebSocket
// server and the ApolloServer to this HTTP server.
const app = express();
const httpServer = createServer(app);

// Set up WebSocket server.
const wsServer = new WebSocketServer({
  server: httpServer,
  path: '/graphql',
});
const serverCleanup = useServer({ schema }, wsServer);

// Set up ApolloServer.
const server = new ApolloServer({
  schema,
  plugins: [
    // Proper shutdown for the HTTP server.
    ApolloServerPluginDrainHttpServer({ httpServer }),

    // Proper shutdown for the WebSocket server.
    {
      async serverWillStart() {
        return {
          async drainServer() {
            await serverCleanup.dispose();
          },
        };
      },
    },
  ],
});

await server.start();

//middleware injection
//cors middleware
//bodyParser middleware , convert incoming json into js object
app.use('/graphql', cors<cors.CorsRequest>(), bodyParser.json(), expressMiddleware(server));

// Now that our HTTP server is fully set up, actually listen.
httpServer.listen(PORT, () => {
  console.log(`ðŸš€ Query endpoint ready at http://localhost:${PORT}/graphql`);
  console.log(`ðŸš€ Subscription endpoint ready at ws://localhost:${PORT}/graphql`);
});

// In the background, increment a number every second and notify subscribers when it changes.
function incrementNumber() {
  currentNumber++;
  pubsub.publish('NUMBER_INCREMENTED', { numberIncremented: currentNumber });
  setTimeout(incrementNumber, 1000);
}

// Start incrementing
incrementNumber();










